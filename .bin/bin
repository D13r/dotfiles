#!/usr/bin/env bash
################################################################################
# Bin - A simple task runner           Copyright (c) 2023-24 Dave James Miller #
# https://github.com/bin-cli/bin-cli   MIT License                             #
################################################################################

# This is the minified version with comments and indentation removed






















































set -euo pipefail





shopt -s nullglob









readonly VERSION='v0.9.0'




if [[ -t 1 ]]; then

# kcov-ignore-start: There is never a terminal connected during unit tests
readonly RESET=$'\e[0m'
readonly BOLD=$'\e[1m'
readonly UNDERLINE=$'\e[4m'
readonly YELLOW=$'\e[33m'
readonly GREY=$'\e[90m'
readonly LCYAN=$'\e[96m'
readonly LWHITE=$'\e[97m'
# kcov-ignore-end
else

readonly RESET=''
readonly BOLD=''
readonly UNDERLINE=''
readonly YELLOW=''
readonly GREY=''
readonly LCYAN=''
readonly LWHITE=''
fi

readonly NEW_LINE=$'\n'








readonly ERR_NOT_EXECUTABLE=126
readonly ERR_NOT_FOUND=127
readonly ERR_GENERIC=246



declare exe=${0##*/}

fail() {
local code message

message=$1
code=${2-$ERR_GENERIC}





if [[ ${action-} = 'complete-bash' ]]; then
debug "$message"
exit
fi




echo "$exe: $message" >&2
exit "$code"
}














readonly DEBUG_GREY=$'\e[90m'
readonly DEBUG_RESET=$'\e[0m'

debug() {
# kcov-ignore-start: Debug statements are only added when needed
if [[ -n ${BIN_DEBUG_LOG-} ]]; then
local line
line=$(debug_line)
echo "$@" "${DEBUG_GREY}[line $line]${DEBUG_RESET}" >>"$BIN_DEBUG_LOG"
fi
# kcov-ignore-end
}











debug_line() {
local lines
lines=${BASH_LINENO[*]:1:${#BASH_LINENO[@]}-2}
echo "${lines// /, }"
}




bug() {
# kcov-ignore-start: This should never be needed!
local line
line=$(debug_line)
fail "BUG: $1 on line $line"
# kcov-ignore-end
}











declare action=''

set_action() {
if [[ -n $action ]]; then
fail "The '--$action' and '--$1' arguments are incompatible"
fi

action=$1 # global
}



set_option_value() {
local option variable value

option=$1
variable=$2
value=$3

if [[ -z $value ]]; then
fail "The '$option' option requires a value"
fi

eval "$variable=\$value" # global
}














declare fallback=''
declare fixed_bin_dir=''
declare is_custom_exe=false
declare shim=false
declare unique_prefix_matching='' # may be boolean or empty

while [[ $# -gt 0 ]]; do
case $1 in
--complete-bash)    set_action complete-bash ;;
--completion)       set_action completion ;;
--create | -c)      set_action create ;;
--dir)              set_option_value '--dir' fixed_bin_dir "${2-}"; shift ;;
--dir=*)            set_option_value '--dir' fixed_bin_dir "${1#*=}" ;;
--edit | -e)        set_action edit ;;
--exact)            unique_prefix_matching=false ;;
--exe)              is_custom_exe=true; set_option_value '--exe' exe "${2-}"; shift ;;
--exe=*)            is_custom_exe=true; set_option_value '--exe' exe "${1#*=}" ;;
--fallback)         set_option_value '--fallback' fallback "${2-}"; shift ;;
--fallback=*)       set_option_value '--fallback' fallback "${1#*=}" ;;
--help | -h)        set_action help ;;
--info)             set_action info ;;
--prefix)           unique_prefix_matching=true ;;
--shim)             shim=true ;;
--version | -v)     set_action version ;;
--)                 shift; break ;;
-*)                 fail "Invalid option '$1'" ;;
*)                  break ;;
esac

shift
done






if [[ $action = 'help' ]]; then

echo "Usage: $exe [OPTIONS] [--] [COMMAND] [ARGUMENTS...]"
echo
echo "Options that can be used with a command:"
echo "  --dir DIR             Specify the directory name to search for (overrides .binconfig)"
echo "  --exact               Disable unique prefix matching"
echo "  --exe NAME            Override the executable name displayed in the command list"
echo "  --fallback COMMAND    If the command is not found, run the given global command (implies '--exact')"
echo "  --prefix              Enable unique prefix matching (overrides .binconfig)"
echo "  --shim                If the command is not found, run the global command with the same name (implies '--exact')"
echo
echo "Options that do something with a COMMAND:"
echo "  --create, -c          Create the given script and open in your \$EDITOR (implies '--exact')"
echo "  --edit, -e            Open the given script in your \$EDITOR"
echo
echo "Options that do something special and don't accept a COMMAND:"
echo "  --completion          Output a tab completion script for the current shell"
echo "  --info                Display information about the current project (root, bin directory and config file location)"
echo "  --help, -h            Display this help"
echo "  --version, -v         Display the current version number"
echo
echo "Any options must be given before the command, because everything after the command will be passed as parameters to the script."
echo
echo "For more details see https://github.com/bin-cli/bin-cli/tree/$VERSION#readme"
exit
fi

if [[ $action = 'version' ]]; then
echo "Bin CLI $VERSION"
exit
fi



if [[ $action = 'completion' ]]; then
declare complete_command=("$0")
if $is_custom_exe; then
complete_command+=("--exe" "'$exe'")
fi
if [[ -n $fixed_bin_dir ]]; then
complete_command+=("--dir" "'$fixed_bin_dir'")
fi
echo "complete -C \"${complete_command[*]} --complete-bash\" -o default $exe"
exit
fi




declare -i num_parameters_to_ignore=0

if [[ $action = 'complete-bash' ]]; then





declare args=${COMP_LINE:0:$COMP_POINT}

# shellcheck disable=SC2086 # We want this to be split into separate arguments
set -- $args


shift


if [[ $args != *' ' ]]; then
num_parameters_to_ignore=1
fi


can_have_more_options=true

while [[ $# -gt $num_parameters_to_ignore ]]; do
case $1 in
--complete-bash)    fail "Cannot tab complete '$1'" ;;
--completion)       fail "Cannot tab complete '$1'" ;;
--create | -c)      true ;; # Complete as normal to help with creating subcommands
--dir)              set_option_value '--dir' fixed_bin_dir "${2-}"; shift ;;
--dir=*)            set_option_value '--dir' fixed_bin_dir "${1#*=}" ;;
--edit | -e)        true ;; # Complete as normal
--exact)            unique_prefix_matching=false ;;
--exe)              is_custom_exe=true; set_option_value '--exe' exe "${2-}"; shift ;;
--exe=*)            is_custom_exe=true; set_option_value '--exe' exe "${1#*=}" ;;
--fallback)         set_option_value '--fallback' fallback "${2-}"; shift ;;
--fallback=*)       set_option_value '--fallback' fallback "${1#*=}" ;;
--help | -h)        fail "Cannot tab complete '$1'" ;;
--info)             fail "Cannot tab complete '$1'" ;;
--prefix)           unique_prefix_matching=true ;;
--shim)             shim=true ;;
--version | -v)     fail "Cannot tab complete '$1'" ;;
--)                 can_have_more_options=false; shift; break ;;
-*)                 fail "Invalid option '$1'" ;;
*)                  break ;;
esac

shift
done



if $can_have_more_options && [[ ${1-} = -* ]]; then

# kcov-ignore-start: Usage not detected
declare option_names=(

'--completion'
'--create' '-c'
'--dir'
'--edit' '-e'
'--exact'
'--exe'
'--fallback'
'--help' '-h'
'--info'
'--prefix'
'--shim'
'--version' '-v'
'--'
)
# kcov-ignore-end

declare option_name
for option_name in ${option_names+"${option_names[@]}"}; do
if [[ $option_name = "$1"* ]]; then

printf "%s\n" "$option_name"
fi
done

exit
fi

fi




lowercase() {

echo "$1" | tr '[:upper:]' '[:lower:]'
}

trim() {
local string

string=$1


string="${string#"${string%%[![:space:]]*}"}"
string="${string%"${string##*[![:space:]]}"}"

echo "$string"
}




in_array() {
local needle value

needle=$1
shift

for value in "$@"; do
if [[ "$value" = "$needle" ]]; then
return 0
fi
done

return 1
}









map_init() {
local map

map=$1


eval "unset \"\${!map__${map}__@}\"" # global


eval "$map=()" # global
}

map_key() {
local char i key length map

map=$1
key=$2

printf '%s' "map__${map}__"

length="${#key}"
for ((i = 0; i < length; i++)); do
char="${key:i:1}"
case $char in
[a-zA-Z0-9]) printf '%s' "$char" ;;

*) printf '_%02X' "'$char" ;;
esac
done
}

map_set() {
local key map map_key value

map=$1
key=$2
value=$3


map_key=$(map_key "$map" "$key")
printf -v "$map_key" %s "$value" # global


eval "$map+=(\"\$key\")" # global
}

map_get() {
local key map map_key

map=$1
key=$2

map_key=$(map_key "$map" "$key")

if [[ -z ${!map_key+isset} ]]; then
return 1
fi

echo "${!map_key}"
}

map_has() {
local key map map_key

map=$1
key=$2

map_key=$(map_key "$map" "$key")

[[ -n ${!map_key+isset} ]]
}






if [[ $VERSION = 'v1.2.3-dev' ]]; then
readonly ROOT_DIR=${BIN_TEST_ROOT-}
else
readonly ROOT_DIR='' # kcov-ignore-line: Not tested
fi

findup() (
cd "$1"
shift

while true; do

if test "$@"; then
echo "$PWD"
return 0
fi

if [[ ${PWD%/} = "$ROOT_DIR" ]]; then
return 1
fi

cd ..

done
)

is_common_bin_dir() {
in_array "$1" \
"$ROOT_DIR/bin" \
"$ROOT_DIR/usr/bin" \
"$ROOT_DIR/usr/local/bin" \
"$ROOT_DIR/snap/bin" \
"$HOME/.local/bin" \
"$HOME/bin"
}

relative_path() {
local child parent

parent=$1
child=$2

echo "${child#"${parent}/"}"
}








# kcov-ignore-start: Not every code path is covered by our tests
realpath() {
local resolved
resolved=$(resolve_symlinks "$1")
canonicalize_path "$resolved"
}

resolve_symlinks() {
_resolve_symlinks "$1"
}

_resolve_symlinks() {
_assert_no_path_cycles "$@" || return

local dir_context new_context path

if path=$(readlink -- "$1"); then
dir_context=$(dirname -- "$1")
new_context=$(_prepend_dir_context_if_necessary "$dir_context" "$path")
_resolve_symlinks "$new_context" "$@"
else
echo "$1"
fi
}

_prepend_dir_context_if_necessary() {
if [[ $1 = '.' ]]; then
echo "$2"
else
_prepend_path_if_relative "$1" "$2"
fi
}

_prepend_path_if_relative() {
case "$2" in
/*) echo "$2" ;;
*) echo "$1/$2" ;;
esac
}

_assert_no_path_cycles() {
local target path

target=$1
shift

for path in "$@"; do
if [[ "$path" = "$target" ]]; then
return 1
fi
done
}

canonicalize_path() {
if [[ -d $1 ]]; then
_canonicalize_dir_path "$1"
else
_canonicalize_file_path "$1"
fi
}

_canonicalize_dir_path() {
(cd "$1" 2>/dev/null && pwd -P)
}

_canonicalize_file_path() {
local dir file
dir=$(dirname -- "$1")
file=$(basename -- "$1")

(cd "$dir" 2>/dev/null && dir2=$(pwd -P) && echo "$dir2/$file")
}
# kcov-ignore-end











bin_dir_for() {
local bin_dir_real file key line result root_real value

file=$1

line=0
result=''
while IFS='=' read -r key value; do
((line += 1))

key=$(trim "$key")

if binconfig_line_is_ignored "$key"; then

:
elif [[ $key =~ ^\[(.+)]$ ]]; then

break
elif [[ $key = 'dir' ]]; then

value=$(trim "$value")
result="${value%%/}"
break
fi
done <"$file" # kcov-ignore-line: Usage not detected


if [[ -z $result ]]; then
echo 'bin'
return
fi


if [[ $result = /* ]]; then
fail "The option 'dir' cannot be an absolute path in $file line $line"
fi

if [[ ! -d "$root/$result" ]]; then
fail "The directory specified in $file line $line does not exist: $root/$result/"
fi

bin_dir_real=$(realpath "$root/$result")
root_real=$(realpath "$root")
if [[ "$bin_dir_real/" != "$root_real/"* ]]; then
fail "The option 'dir' cannot point to a directory outside $root in $file line $line"
fi

echo "$result"
}





declare -a commands_listed_in_binconfig=()
declare merge_is_optional=false
declare merge_with_parent=false
declare template='_TBC'
map_init command_help

parse_binconfig() {
local binconfig bin_dir command key line root value

binconfig=$1
root=$2
bin_dir=$3

command=''
line=0

# shellcheck disable=SC2094 # We aren't writing to $binconfig but it thinks we might be
while IFS='=' read -r key value; do
((line += 1))

key=$(trim "$key")
value=$(trim "$value")

if binconfig_line_is_ignored "$key"; then
: # Skip blank lines & comments
elif [[ $key =~ ^\[(.+)]$ ]]; then
command=${BASH_REMATCH[1]}
commands_listed_in_binconfig+=("$command") # global
elif [[ -n $command ]]; then
set_command_option "$command" "$key" "$value" "$binconfig" "$line" "$root" "$bin_dir"
else
set_global_option "$key" "$value" "$binconfig" "$line"
fi
done <"$binconfig" # kcov-ignore-line: Usage not detected
}

set_global_option() {
local binconfig key line value value_lowercase

key=$1
value=$2
binconfig=$3
line=$4

if [[ $key = 'dir' ]]; then

: # Already handled in 'get_dir_from_binconfig'

elif [[ $key = 'exact' ]]; then



value_lowercase=$(lowercase "$value")

if in_array "$value_lowercase" 'false' 'no' 'off' '0'; then

if [[ -z $unique_prefix_matching ]]; then
unique_prefix_matching=true
fi
elif in_array "$value_lowercase" 'true' 'yes' 'on' '1'; then
if [[ -z $unique_prefix_matching ]]; then
unique_prefix_matching=false
fi
else
fail "Invalid value for 'exact' in $binconfig line $line: $value"
fi

elif [[ $key = 'merge' ]]; then

value_lowercase=$(lowercase "$value")

if in_array "$value_lowercase" 'false' 'no' 'off' '0'; then
merge_with_parent=false # global
elif in_array "$value_lowercase" 'true' 'yes' 'on' '1'; then
merge_with_parent=true # global
merge_is_optional=false # global
elif [[ $value_lowercase = 'optional' ]]; then
merge_with_parent=true # global
merge_is_optional=true # global
else
fail "Invalid value for 'merge' in $binconfig line $line: $value"
fi

elif [[ $key = 'template' ]]; then

if [[ $template = '_TBC' ]]; then
template=$value
fi

else


debug "Ignored unknown key '$key' in $binconfig line $line"

fi
}

set_command_option() {
local binconfig bin_dir command key line root value value_lowercase

command=$1
key=$2
value=$3
binconfig=$4
line=$5
root=$6
bin_dir=$7

if [[ $key = 'alias' || $key = 'aliases' ]]; then

IFS=',' read -ra line_aliases <<<"$value"
for alias in ${line_aliases+"${line_aliases[@]}"}; do
alias=$(trim "$alias")
register_command_alias "$alias" "$command" "$binconfig line $line"
done

elif [[ $key = 'command' ]]; then

register_inline_command "$command" "$value" "$binconfig line $line" "$root" "$bin_dir"

elif [[ $key = 'help' ]]; then

if [[ -n "$value" ]]; then
register_command_help "$command" "$value"
fi

else


debug "Ignored unknown key '$key' in $binconfig line $line"

fi
}






binconfig_line_is_ignored() {
[[ $1 = '' || $1 = '#'* || $1 = ';'* ]]
}









declare -a broken_symlinks=()
declare -a non_executable_files=()
declare -a registered_commands=()
map_init command_to_bin_dir
map_init command_to_executable
map_init command_to_inline_script
map_init command_to_root
map_init executable_to_command
map_init original_commands

prevent_duplicate_command() {
local name source type

type=$1
name=$2
source=$3

for command in ${registered_commands+"${registered_commands[@]}"}; do
if command_matches exact "$name" "$command" ||

command_matches subcommands "$name" "$command" ||
command_matches subcommands "$command" "$name"
then
fail "The $type '$name' defined in $source conflicts with an existing command"
fi
done
}

register_executable_command() {
local executable name

name=$1
executable=$2

prevent_duplicate_command command "$name" "$executable"

registered_commands+=("$name")                      # global
map_set command_to_executable "$name" "$executable" # global
map_set executable_to_command "$executable" "$name" # global
map_set original_commands "$name" "$name"           # global
}

register_inline_command() {
local bin_dir name root script source

name=$1
script=$2
source=$3
root=$4
bin_dir=$5

prevent_duplicate_command command "$name" "$source"

registered_commands+=("$name")                     # global
map_set command_to_inline_script "$name" "$script" # global
map_set command_to_root "$name" "$root"            # global
map_set command_to_bin_dir "$name" "$bin_dir"      # global
map_set original_commands "$name" "$name"          # global
}

register_commands_in_directory() {
local directory file is_root_dir name prefix realfile target

directory=$1
is_root_dir=$2
prefix=${3-}


for file in "$directory/"*; do
name=${file##*/}  # Remove path
name=${name// /-} # Spaces to dashes

realfile=$(realpath "$file") || true

if [[ -L $file ]]; then
target=$(readlink "$file")
if [[ $target = /* ]]; then
fail "The symlink '$file' must use a relative path, not absolute ('$target')"
fi
if [[ -e $file ]]; then
register_symlink_alias "$prefix$name" "$realfile" "$file"
else
broken_symlinks+=("$file => $target")
fi
elif [[ -d $file ]]; then




if ! $is_root_dir; then
map_set executable_to_command "$realfile" "$prefix$name" # global
register_commands_in_directory "$file" "$is_root_dir" "$prefix$name "
fi
elif [[ ! -x $file ]]; then
if ! $is_root_dir; then
non_executable_files+=("$file") # global
fi
else


if ! ($is_root_dir && [[ $name =~ \.(json|md|txt|yaml|yml)$ ]]); then
register_executable_command "$prefix$name" "$realfile"
fi
fi
done
}




declare -a aliases=()
map_init alias_sources
map_init alias_to_executable

prevent_duplicate_alias() {
local existing name source

name=$1
source=$2

if existing=$(map_get alias_sources "$name"); then
fail "The alias '$name' defined in $source conflicts with the alias defined in $existing"
fi
}

register_command_alias() {
local alias command source

alias=$1
command=$2
source=$3

prevent_duplicate_alias "$alias" "$source"

aliases+=("$alias")                           # global
map_set original_commands "$alias" "$command" # global
map_set alias_sources "$alias" "$source"      # global
}

register_symlink_alias() {
local alias executable source

alias=$1
executable=$2
source=$3

prevent_duplicate_alias "$alias" "$source"

aliases+=("$alias")                                # global
map_set alias_to_executable "$alias" "$executable" # global
map_set alias_sources "$alias" "$source"           # global
}




declare -a matching_commands=()

command_matches() {
local command found target type

type=$1
target=$2
command=$3


found=false

if [[ $type = exact ]]; then
[[ "$command" = "$target" ]] && found=true
elif [[ $type = with-extension ]]; then
[[ "$command" = "$target".* ]] && found=true
elif [[ $type = subcommands ]]; then
[[ "$command" = "$target "* ]] && found=true
elif [[ $type = prefix ]]; then
[[ "$command" = "$target"* ]] && found=true
else
bug "Invalid \$type '$type' passed to command_matches()" # kcov-ignore-line: This should never be happen
fi


if ! $found; then
return 1
fi

return 0
}

is_hidden_command() {
local command prefix_length target

command=$1
target=${2-}



prefix_length=${#target}

if [[ $prefix_length -eq 0 ]]; then
command=" $command"
else
command="${command:$prefix_length}"
fi

[[ $command = *' _'* ]]
}

find_matching_commands() {
local alias command target type

type=$1
target=$2
stop_after_first=${3-false}


map_init commands_matching_aliases # global

for alias in ${aliases+"${aliases[@]}"}; do
if command_matches "$type" "$target" "$alias"; then
command=$(map_get original_commands "$alias")
map_set commands_matching_aliases "$command" true # global
fi
done


matching_commands=() # global

for command in ${registered_commands+"${registered_commands[@]}"}; do
if map_has commands_matching_aliases "$command" || command_matches "$type" "$target" "$command"; then
matching_commands+=("$command") # global


if $stop_after_first; then
break
fi
fi
done
}

has_matching_commands() {
local alias command target type

type=$1
target=$2

find_matching_commands "$type" "$target" true

[[ ${#matching_commands[@]} -gt 0 ]]
}

matching_commands_shared_prefix() {
local command next_command prefix prefix_length remaining shared_next_command

prefix=$1
prefix_length=${#prefix}

shared_next_command=''

for command in ${matching_commands+"${matching_commands[@]}"}; do

remaining=${command:$prefix_length}

if [[ ! $remaining = *' '* ]]; then
continue
fi

next_command=${remaining/ */}

if [[ -z $shared_next_command ]]; then
shared_next_command=$next_command
elif [[ "$next_command" != "$shared_next_command" ]]; then

return 1
fi
done

if [[ -n $shared_next_command ]]; then
echo "$prefix$shared_next_command"
else

return 1
fi
}




open_in_editor() {
local editor file

file=$1

editor=${VISUAL-${EDITOR-}}

if [[ -z $editor ]]; then
if command -v editor &>/dev/null; then
editor='editor'
elif command -v nano &>/dev/null; then
editor='nano'
elif command -v vi &>/dev/null; then
editor='vi'
else
fail 'No editor configured - please export EDITOR or VISUAL environment variables'
fi
fi

exec "$editor" "$file"
}

run_command() {
if [[ $action = 'complete-bash' ]]; then
bug 'run_command() should not be reached during tab completion' # kcov-ignore-line: This should never be happen
elif [[ $action = 'create' ]]; then
fail "$1 already exists (use --edit to edit it)"
elif [[ $action = 'edit' ]]; then
open_in_editor "$1"
else
exec "$@"
fi
}

run_command_if_only_one_match() {
local command executable root script

if [[ ${#matching_commands[@]} -ne 1 ]]; then
return
fi

command=${matching_commands[0]}



export BIN_COMMAND="$exe $command"


export BIN_EXE="$exe"

if executable=$(map_get command_to_executable "$command"); then
run_command "$executable" "$@"
fi

if script=$(map_get command_to_inline_script "$command"); then

if [[ $action = 'edit' ]]; then
root=$(map_get command_to_root "$command")
open_in_editor "$root/.binconfig"
fi



export BIN_ROOT BIN_DIR
BIN_ROOT=$(map_get command_to_root "$command")
BIN_DIR=$(map_get command_to_bin_dir "$command")

run_command bash -c "$script" -- "$@"
fi

bug 'Reached the end of run_command_if_only_one_match() without running a command' # kcov-ignore-line: This should never be happen
}




register_command_help() {
local command help

command=$1
help=$2

map_set command_help "$command" "$help" # global
}

get_command_help() {
local command original_command

command=$1

original_command=$(map_get original_commands "$command")
map_get command_help "$original_command"
}




declare main_bin_dir=''
declare main_bin_dir_from_root=''
declare main_binconfig=''
declare main_is_root_dir=false
declare main_root=''
declare merging=false
declare start_directory=$PWD

while true; do

declare root=''
declare binconfig=''
declare bin_dir=''
declare bin_dir_from_root=''
declare is_root_dir=false


if [[ -n $fixed_bin_dir ]]; then





if [[ $fixed_bin_dir = /* ]]; then

if [[ ! -d $fixed_bin_dir ]]; then
fail "Specified directory '$fixed_bin_dir/' is missing"
fi

bin_dir=$fixed_bin_dir
else

if ! dir_parent=$(findup "$start_directory" -d "$fixed_bin_dir"); then
fail "Could not find '$fixed_bin_dir/' directory starting from '$start_directory'" $ERR_NOT_FOUND
fi

bin_dir="$dir_parent/$fixed_bin_dir"
fixed_bin_dir=''
fi



binconfig=''
root=$(dirname "$bin_dir")
bin_dir_from_root=$(basename "$bin_dir")

if binconfig_dir=$(findup "$bin_dir" -f .binconfig); then
binconfig_file="$binconfig_dir/.binconfig"
dir_in_binconfig=$(bin_dir_for "$binconfig_file")
required_dir=$(relative_path "$binconfig_dir" "$bin_dir")

if [[ "$dir_in_binconfig" = "$required_dir" ]]; then
binconfig=$binconfig_file
root=$binconfig_dir
bin_dir_from_root=$required_dir
fi
fi

elif root=$(findup "$start_directory" -f .binconfig); then


binconfig="${root%/}/.binconfig"
bin_dir_from_root=$(bin_dir_for "$binconfig")

if [[ $bin_dir_from_root = '.' ]]; then
bin_dir=${root%/}
else
bin_dir="${root%/}/$bin_dir_from_root"
fi

else


if ! root=$(findup "$start_directory" -d bin); then
if $merge_is_optional; then
break
elif $merging; then

fail "Could not find 'bin/' directory or '.binconfig' file starting from '$start_directory' (merge=true)" $ERR_GENERIC
else

fail "Could not find 'bin/' directory or '.binconfig' file starting from '$start_directory'" $ERR_NOT_FOUND
fi
fi

binconfig="${root%/}/.binconfig"
bin_dir_from_root='bin'
bin_dir="${root%/}/bin"


if is_common_bin_dir "$bin_dir"; then
if $merge_is_optional; then
break
elif $merging; then

fail "Could not find 'bin/' directory or '.binconfig' file starting from '$start_directory' (merge=true) (ignored '$bin_dir')" $ERR_GENERIC
else

fail "Could not find 'bin/' directory or '.binconfig' file starting from '$start_directory' (ignored '$bin_dir')" $ERR_NOT_FOUND
fi
fi
fi


if [[ $bin_dir_from_root = '.' ]]; then
is_root_dir=true
fi


if [[ -d $bin_dir ]]; then
register_commands_in_directory "$bin_dir" "$is_root_dir"
fi


if [[ -f $binconfig ]]; then
parse_binconfig "$binconfig" "$root" "$bin_dir"
fi


if [[ -z $unique_prefix_matching ]]; then
unique_prefix_matching=true
fi


if [[ -z $main_root ]]; then
main_binconfig=$binconfig
main_bin_dir=$bin_dir
main_bin_dir_from_root=$bin_dir_from_root
main_is_root_dir=$is_root_dir
main_root=$root
fi


if [[ $action = 'info' ]]; then
if $merging; then
echo
fi

echo "Root:    $root/"

if [[ -f $binconfig ]]; then
echo "Config:  $binconfig"
else
echo "Config:  $binconfig (missing)"
fi

if [[ -d $bin_dir ]]; then
echo "Bin Dir: $bin_dir/"
else
echo "Bin Dir: $bin_dir/ (missing)"
fi

if ! $merge_with_parent; then
echo "Merge:   false"
elif $merge_is_optional; then
echo "Merge:   optional"
else
echo "Merge:   true"
fi
fi


if ! $merge_with_parent; then
break
fi

merge_with_parent=false
merging=true
start_directory=$(dirname "$root")

done

if [[ $action = 'info' ]]; then
exit
fi


# shellcheck disable=SC2154 # It doesn't recognise 'map_init' and 'map_set' as setting this variable
for alias in ${alias_to_executable+"${alias_to_executable[@]}"}; do
if executable=$(map_get alias_to_executable "$alias"); then
command=$(map_get executable_to_command "$executable")
map_set original_commands "$alias" "$command"
fi
done

for alias in ${aliases+"${aliases[@]}"}; do

source=$(map_get alias_sources "$alias")
prevent_duplicate_command alias "$alias" "$source"


target=$(map_get original_commands "$alias")
for command in ${registered_commands+"${registered_commands[@]}"}; do
if [[ "$command" = "$target "* ]]; then
suffix=${command:${#target}}
aliases+=("$alias$suffix")
map_set original_commands "$alias$suffix" "$target$suffix"
fi
done
done





declare command_list_title='Available Commands'
declare -a command_list=(${registered_commands+"${registered_commands[@]}"})


declare current_directory=$main_bin_dir
declare full_command=''

while [[ $# -gt $num_parameters_to_ignore ]]; do
declare subcommand=$1
shift


if [[ -z $full_command && $subcommand = '.binconfig' ]]; then
if [[ $action = 'create' ]]; then
if [[ -e "$main_root/.binconfig" ]]; then
fail "$main_root/.binconfig already exists (use --edit to edit it)"
fi

( # kcov-ignore-line: Usage not detected
declare output_started=false

if [[ $main_bin_dir_from_root != 'bin' ]]; then
echo "dir = $main_bin_dir_from_root"
output_started=true
fi

for command in ${registered_commands+"${registered_commands[@]}"}; do
if $output_started; then
echo
fi
echo "[$command]"
echo 'alias ='
echo 'help ='
output_started=true
done

if ! $output_started; then
echo
fi
) >"$main_root/.binconfig" # kcov-ignore-line: Usage not detected

echo "Created file $main_root/.binconfig"
open_in_editor "$main_root/.binconfig"
elif [[ $action = 'edit' ]]; then
if [[ ! -e "$main_root/.binconfig" ]]; then
fail 'No .binconfig file found (use --create to create one)'
fi

bin_dir_for_binconfig=$(bin_dir_for "$main_root/.binconfig")
if [[ "$bin_dir_for_binconfig" != "$main_bin_dir_from_root" ]]; then
fail ".binconfig belongs to $bin_dir_for_binconfig/ not $main_bin_dir_from_root/"
fi

open_in_editor "$main_root/.binconfig"
fi
fi


full_command+=" $subcommand"


find_matching_commands exact "${full_command:1}"
run_command_if_only_one_match "$@"


find_matching_commands with-extension "${full_command:1}"
run_command_if_only_one_match "$@"


find_matching_commands subcommands "${full_command:1}"

if [[ ${#matching_commands[@]} -gt 0 ]]; then
current_directory="$current_directory/$subcommand"
command_list_title='Available Subcommands'
command_list=(${matching_commands+"${matching_commands[@]}"})
continue
fi


if [[ $action = 'create' ]]; then
if [[ $subcommand = .* ]]; then
fail "Command names may not start with '.'"
fi

if [[ $# -gt 0 ]]; then
current_directory="$current_directory/$subcommand"
continue
fi

mkdir -p "$current_directory"
declare script="$current_directory/$subcommand"

if [[ $template = '_TBC' ]]; then




template='#!/usr/bin/env bash\nset -euo pipefail\n\n'
fi

echo -e "$template" >"$script"
chmod +x "$script"
echo "Created script $script"
open_in_editor "$script"
elif $shim; then
# shellcheck disable=SC2086 # We want word splitting here
run_command ${full_command:1} "$@"
elif [[ -n $fallback ]]; then
# shellcheck disable=SC2086 # We want word splitting here (the fallback command may contain arguments)
run_command $fallback "$@"
fi



find_matching_commands prefix "${full_command:1}"

if $unique_prefix_matching && parent=$(matching_commands_shared_prefix "${full_command:1}"); then


current_directory="$current_directory/$parent"
full_command=" $parent"
command_list_title='Matching Commands'
command_list=(${matching_commands+"${matching_commands[@]}"})
continue
fi

if $unique_prefix_matching; then
run_command_if_only_one_match "$@"
fi


if [[ ${#matching_commands[@]} -eq 0 ]]; then
if $main_is_root_dir && [[ -d "$current_directory/$subcommand" ]]; then
fail "Subcommands are not supported with the config option 'dir = $main_bin_dir_from_root'"
fi
if [[ $subcommand = .* && -e "$current_directory/$subcommand" ]]; then
fail "Command names may not start with '.'"
fi
if [[ -f "$current_directory/$subcommand" && ! -x "$current_directory/$subcommand" ]]; then
fail "'$current_directory/$subcommand' is not executable (chmod +x)" $ERR_NOT_EXECUTABLE
fi

append=''
if in_array "${full_command:1}" completion create edit help info version; then
append="${NEW_LINE}${GREY}Perhaps you meant to run 'bin --${full_command:1}'?${RESET}"
fi
fail "Command '${full_command:1}' not found in $main_bin_dir/ or $main_binconfig$append" $ERR_NOT_FOUND
fi


command_list_title='Matching Commands'
command_list=(${matching_commands+"${matching_commands[@]}"})
break
done




remove_extension() {
local command



command="$1"

while [[ "$command" =~ (.*)(\.[a-zA-Z0-9]+)+ ]]; do
command=${BASH_REMATCH[1]}
done

echo "$command"
}

has_duplicate() {
local alias command long short

short=$1
long=$2

for command in ${registered_commands+"${registered_commands[@]}"}; do
case "$command" in

"$long") continue ;;

"$short") return 0 ;;
"$short."*) return 0 ;;
"$short "*) return 0 ;;
*) continue ;;
esac
done

for alias in ${aliases+"${aliases[@]}"}; do
case "$alias" in
"$short") return 0 ;;
"$short "*) return 0 ;;
*) continue ;;
esac
done


return 1
}


declare -a shortened_commands=()

for command in ${command_list+"${command_list[@]}"}; do
short=$(remove_extension "$command")

if [[ "$short" = "$command" ]]; then
shortened_commands+=("$command")
elif has_duplicate "$short" "$command"; then
shortened_commands+=("$command")
else
shortened_commands+=("$short")
original_command=$(map_get original_commands "$command")
map_set original_commands "$short" "$original_command"
fi
done


declare -a shortened_aliases=()

for alias in ${aliases+"${aliases[@]}"}; do
short=$(remove_extension "$alias")

if [[ "$short" = "$alias" ]]; then
shortened_aliases+=("$alias")
elif has_duplicate "$short" "$alias"; then
shortened_aliases+=("$alias")
else
shortened_aliases+=("$short")
original_command=$(map_get original_commands "$alias")
map_set original_commands "$short" "$original_command"
fi
done




if [[ $action = 'complete-bash' ]]; then


declare parent_command=''
if [[ -n $full_command ]]; then
parent_command="${full_command:1} "
fi

declare current_command=${1-}
declare typed_command="$parent_command$current_command"


declare alias command match
declare -a possible_results=()
declare -a matched_commands=()

for command in ${shortened_commands+"${shortened_commands[@]}"}; do
if ! command_matches prefix "$typed_command" "$command"; then
continue
fi

match=${command#"$parent_command"} # Remove everything before the current argument
match=${match/ */} # Remove everything after the current argument (i.e. subcommands)
possible_results+=("$match")
matched_commands+=("$command")
done

for alias in ${shortened_aliases+"${shortened_aliases[@]}"}; do
if ! command_matches prefix "$typed_command" "$alias"; then
continue
fi




command=$(map_get original_commands "$alias")
if in_array "$command" ${matched_commands+"${matched_commands[@]}"}; then
continue
fi

match=${alias#"$parent_command"} # Remove everything before the current argument
match=${match/ */} # Remove everything after the current argument (i.e. subcommands)
possible_results+=("$match")
matched_commands+=("$command")
done


for result in ${possible_results+"${possible_results[@]}"}; do


if is_hidden_command "$result" "$current_command"; then
continue
fi

echo "$result"
done | sort | uniq

exit
fi





get_command_aliases() {
local alias command command_alias_count command_aliases original_command target

command=$1

command_alias_count=0
command_aliases=''

original_command=$(map_get original_commands "$command")

for alias in ${shortened_aliases+"${shortened_aliases[@]}"}; do
target=$(map_get original_commands "$alias")
if [[ "$target" = "$original_command" ]]; then
((command_alias_count += 1))
command_aliases+=", $alias"
fi
done

if [[ $command_alias_count -eq 1 ]]; then
echo "alias: ${command_aliases:2}"
elif [[ $command_alias_count -gt 1 ]]; then
echo "aliases: ${command_aliases:2}"
else
return 1
fi
}


declare -a visible_commands=()

for command in ${shortened_commands+"${shortened_commands[@]}"}; do
if ! is_hidden_command "$command" "${full_command:1}"; then
visible_commands+=("$command")
fi
done


declare -i maxlength=0

for command in ${visible_commands+"${visible_commands[@]}"}; do
if [[ ${#command} -gt $maxlength ]]; then
maxlength=${#command}
fi
done


echo "$LCYAN$BOLD$UNDERLINE$command_list_title$RESET"


declare command command_aliases help

for command in ${visible_commands+"${visible_commands[@]}"}; do
if help=$(get_command_help "$command"); then
if command_aliases=$(get_command_aliases "$command"); then
printf "$LWHITE%s %-${maxlength}s$RESET    %s $GREY(%s)$RESET\n" "$exe" "$command" "$help" "$command_aliases"
else
printf "$LWHITE%s %-${maxlength}s$RESET    %s\n" "$exe" "$command" "$help"
fi
else
if command_aliases=$(get_command_aliases "$command"); then
printf "$LWHITE%s %-${maxlength}s$RESET    $GREY(%s)$RESET\n" "$exe" "$command" "$command_aliases"
else
printf "$LWHITE%s %s$RESET\n" "$exe" "$command"
fi
fi
done | sort

if [[ ${#visible_commands[@]} -eq 0 ]]; then
echo "${GREY}None found${RESET}"
fi


if [[ ${#broken_symlinks[@]} -gt 0 ]]; then
echo
echo "${YELLOW}Warning: The following symlinks point to targets that don't exist:${RESET}"
declare symlink
for symlink in ${broken_symlinks+"${broken_symlinks[@]}"}; do
echo "$symlink"
done
fi


if [[ ${#non_executable_files[@]} -gt 0 ]]; then
echo
echo "${YELLOW}Warning: The following files are not executable (chmod +x):${RESET}"
declare file
for file in ${non_executable_files+"${non_executable_files[@]}"}; do
echo "$file"
done
fi


missing_commands=()

for command in ${commands_listed_in_binconfig+"${commands_listed_in_binconfig[@]}"}; do


if map_has command_to_executable "$command"; then
continue
fi


if map_has command_to_inline_script "$command"; then
continue
fi


if has_matching_commands subcommands "$command"; then
continue
fi

missing_commands+=("$command")
done

if [[ ${#missing_commands[@]} -gt 0 ]]; then
echo
echo "${YELLOW}Warning: The following commands listed in .binconfig do not exist:${RESET}"
declare command
for command in ${missing_commands+"${missing_commands[@]}"}; do
echo "[$command]"
done
fi


